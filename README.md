
# Access Card Administration 

A terminal-based Access Card Administration program written in C (C++), designed to manage and control card-based access for a secure system.
The application allows administrators to add, remove, adjust, and list access cards, simulate remote door access, and handle card scanning through a text-based menu system.


## Features

- Add, remove, and modify card profiles
- Persistent data storage (via data/data.txt)
- Simulated cardscaning through terminal
- Safe input handling and buffer validation
- File read/write support through modular headers
- Time-delayed CLI feedback
- Color-coded terminal interface
- Dynamic display of cardlist


## Screenshots

<div style="display: flex; justify-content: center; gap: 2%;">
  <img src="screenshots/image1.png" alt="Main Menu" style="width: 48%; height: 300px; object-fit: cover;" />
  <img src="screenshots/image.png" alt="Card List" style="width: 48%; height: 300px; object-fit: cover;" />
</div>


## Project Structure
```bash
 Project/
├── src/                  # Source files
│   ├── main.c
│   ├── fileHandeling.c
│   ├── addRemoveAcces.c
│   ├── printcards.c
│   ├── timeDelay.c
│   ├── remoteopen.c
│   ├── safeinput.c
│   ├── cardScan.c
│   ├── clearCls.c
│   └── colorpallet.c
├── includes/             # Header files
│   ├── menu.h
│   ├── fileHandeling.h
│   ├── addRemoveAcces.h
│   ├── printcards.h
│   ├── timeDelay.h
│   ├── remoteopen.h
│   ├── safeinput.h
│   ├── cardScan.h
│   ├── clearCls.h
│   └── colorpallet.h
├── obj/                  # Object files (.o) generated by Makefile
├── Makefile              # Build instructions
├── data/                 # Card data storage
│   └── data.txt
└── README.md
```

## Program Workflow

main.c (in src/) is the program entry point. Workflow:

Initialize system

Loads card data from data/data.txt into memory.

Main Menu Options

1 — Remote Open: Open a door remotely with admin credentials.

2 — List Cards: Display all cards in the system.

3 — Manage Cards: Add, adjust, or remove card profiles. Users can repeatedly add or modify cards until they return to the main menu.

4 — Scan Card: Simulate scanning a card to verify access.

5 — Exit: Frees memory and exits.

Input Validation

All inputs are validated with ValidateResult() to ensure safe operations.

Memory Management

Dynamically allocated memory for the card list is freed before exiting.

## Data structures

#### Card
```bash
  typedef struct {
    int cardUid;
    int status;      // 0 = no access, 1 = access
    char date[20];   // "YYYY-MM-DD HH:MM"
} Card;

```
#### CARDLIST
```bash
  typedef struct {
    int amountOfCards;
    Card *allCards;   // dynamically allocated array of Card
} CARDLIST;

```

## Compilation & Execution
- Requirements

- GCC (GNU Compiler Collection)

- Make (optional)

- Compatible with Linux / macOS / Windows (MinGW) terminal

GCC compiler for windows:
https://www.msys2.org/


#### Compile manually:

```bash
  gcc -o access_admin main.c -Wall
```
#### If your project uses multiple .c source files, compile them together:

```bash
  gcc -o access_admin main.c fileHandeling.c addRemoveAcces.c printcards.c timeDelay.c remoteopen.c safeinput.c cardScan.c clearCls.c -Wall
```

#### Then run:

```bash
  ./access_admin
```


## Memory Safety and Error Handeling
- Dynamic memory is allocated with mallock() and realloc.
- Memory is freed when cards are removed and when no cards remain.
- User input is strictly validated to prevent buffer owerflow.
- File operations check for faliures and handel errors.
- Numeric inputs are checked for range, type and owerflow.
- All finctions return clear INPUT_RESULT values for robust error handeling.


### Code examples

##### Dynamic UID Generation and Sorting
```bash
  cardList->allCards = realloc(cardList->allCards, (sizeof(Card) * (*amountOfCards +1)));
  if (!cardList->allCards) {
      perror("realloc failed");
      exit(EXIT_FAILURE);
  }
  int newCard = 110001; //startingpoint for card Uid
  int acces;
  int insertionPoint = *amountOfCards;

  if(*amountOfCards == 0){ 
      insertionPoint = 0;
      cardList ->allCards[insertionPoint].cardUid = newCard; // assign if no cards i system
  }else{    

      for(int i = 0; i < *amountOfCards; i++){ 
          if(cardList ->allCards[i].cardUid <= newCard){ //check all card Uid and increas new Uid untill uniqe
              newCard++;
          }else{ // when confirmed new Uid is uniq   
              break;
          }
      }   
  }
```
```bash
  int sortCardArray(CARDLIST *cardList, int *amountOfCards, int *newCard){
  int i = *amountOfCards - 1;

  while(i >= 0 && cardList->allCards[i].cardUid > *newCard){
      cardList->allCards[i + 1] = cardList->allCards[i];
      i--;
  }

  return i + 1;
}
```

Highlights

- Keeps the system the comsistant and esures UID uniquenes.
- Avoids unnecesary memmory use from using ex. buffer array.
- Avoids the nead to re-srot the entire array after each insertion
- Efficiently insert new card while keeping the array sorted.


## Summary

This project demonstrates mamory management, input validation and file persistance for an access contorl system.

- Modular design for easy maintenance and testing.
- Suports dynamic scaling of data.
- Emphasizes Safety operations and user-frendly interactions.

Potential improvements

- Add concurrency suport for scaning multiple cards in real-time.
- Proper hardware integation.
- Card Uid incryption.

## Author

 GitHub Profile
 raspants


